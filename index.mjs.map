{"version":3,"file":"index.mjs","sources":["../lib/internal_compreal.js","../lib/robust_internal.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Computes the real part of the quotient.\n*\n* ## Notes\n*\n* -   See figure 10 of [Baudin (2012)][@baudin:2012].\n*\n* [@baudin:2012]: https://arxiv.org/abs/1210.4539\n*\n* @private\n* @param {number} re1 - real component\n* @param {number} im1 - imaginary component\n* @param {number} re2 - real component\n* @param {number} im2 - imaginary component\n* @param {number} r - partial result\n* @param {number} t - partial result\n* @returns {number} real part of the quotient\n*/\nfunction internalCompreal( re1, im1, re2, im2, r, t ) {\n\tvar br;\n\tif ( r === 0.0 ) {\n\t\treturn ( re1 + (im2 * (im1/re2)) ) * t;\n\t}\n\tbr = im1 * r;\n\tif ( br === 0.0 ) {\n\t\treturn ( re1*t ) + ( (im1*t) * r );\n\t}\n\treturn ( re1+br ) * t;\n}\n\n\n// EXPORTS //\n\nexport default internalCompreal;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport internalCompreal from './internal_compreal.js';\n\n\n// MAIN //\n\n/**\n* Computes the complex division.\n*\n* ## Notes\n*\n* -   See figure 10 of [reference][@baudin:2012].\n*\n* [@baudin:2012]: https://arxiv.org/abs/1210.4539\n*\n* @private\n* @param {number} re1 - real component\n* @param {number} im1 - imaginary component\n* @param {number} re2 - real component\n* @param {number} im2 - imaginary component\n* @returns {Array<number>} result\n*/\nfunction robustInternal( re1, im1, re2, im2 ) {\n\tvar out;\n\tvar r;\n\tvar t;\n\n\tout = [ 0.0, 0.0 ];\n\tr = im2 / re2;\n\tt = 1.0 / ( re2 + (im2*r) );\n\n\tout[ 0 ] = internalCompreal( re1, im1, re2, im2, r, t );\n\tout[ 1 ] = internalCompreal( im1, -re1, re2, im2, r, t );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default robustInternal;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport abs from '@stdlib/math-base-special-abs';\nimport max from '@stdlib/math-base-special-max';\nimport FLOAT64_BIGGEST from '@stdlib/constants-float64-max';\nimport FLOAT64_SMALLEST from '@stdlib/constants-float64-smallest-normal';\nimport EPS from '@stdlib/constants-float64-eps';\nimport real from '@stdlib/complex-float64-real';\nimport imag from '@stdlib/complex-float64-imag';\nimport Complex128 from '@stdlib/complex-float64-ctor';\nimport robustInternal from './robust_internal.js';\n\n\n// VARIABLES //\n\nvar LARGE_THRESHOLD = FLOAT64_BIGGEST * 0.5;\nvar SMALL_THRESHOLD = FLOAT64_SMALLEST * ( 2.0 / EPS );\nvar RECIP_EPS_SQR = 2.0 / ( EPS * EPS );\n\n\n// MAIN //\n\n/**\n* Divides two double-precision complex floating-point numbers.\n*\n* ## References\n*\n* -   Baudin, Michael, and Robert L. Smith. 2012. \"A Robust Complex Division in Scilab.\" _arXiv_ abs/1210.4539 \\[cs.MS\\] (October): 1â€“25. <https://arxiv.org/abs/1210.4539>.\n*\n* @param {Complex128} z1 - complex number\n* @param {Complex128} z2 - complex number\n* @returns {Complex128} result\n*\n* @example\n* import Complex128 from '@stdlib/complex-float64-ctor';\n* import real from '@stdlib/complex-float64-real';\n* import imag from '@stdlib/complex-float64-imag';\n*\n* var z1 = new Complex128( -13.0, -1.0 );\n* // returns <Complex128>\n*\n* var z2 = new Complex128( -2.0, 1.0 );\n* // returns <Complex128>\n*\n* var out = cdiv( z1, z2 );\n* // returns <Complex128>\n*\n* var re = real( out );\n* // returns 5.0\n*\n* var im = imag( out );\n* // returns 3.0\n*/\nfunction cdiv( z1, z2 ) {\n\tvar re1;\n\tvar re2;\n\tvar im1;\n\tvar im2;\n\tvar out;\n\tvar ab;\n\tvar cd;\n\tvar s;\n\n\tre1 = real( z1 );\n\tre2 = real( z2 );\n\tim1 = imag( z1 );\n\tim2 = imag( z2 );\n\n\tab = max( abs(re1), abs(im1) );\n\tcd = max( abs(re2), abs(im2) );\n\ts = 1.0;\n\n\tif ( ab >= LARGE_THRESHOLD ) {\n\t\tre1 *= 0.5;\n\t\tim1 *= 0.5;\n\t\ts *= 2.0;\n\t} else if ( ab <= SMALL_THRESHOLD ) {\n\t\tre1 *= RECIP_EPS_SQR;\n\t\tim1 *= RECIP_EPS_SQR;\n\t\ts /= RECIP_EPS_SQR;\n\t}\n\tif ( cd >= LARGE_THRESHOLD ) {\n\t\tre2 *= 0.5;\n\t\tim2 *= 0.5;\n\t\ts *= 0.5;\n\t} else if ( cd <= SMALL_THRESHOLD ) {\n\t\tre2 *= RECIP_EPS_SQR;\n\t\tim2 *= RECIP_EPS_SQR;\n\t\ts *= RECIP_EPS_SQR;\n\t}\n\tif ( abs( im2 ) <= abs( re2 ) ) {\n\t\tout = robustInternal( re1, im1, re2, im2 );\n\t} else {\n\t\tout = robustInternal( im1, re1, im2, re2 );\n\t\tout[ 1 ] *= -1.0;\n\t}\n\tout[ 0 ] *= s;\n\tout[ 1 ] *= s;\n\treturn new Complex128( out[ 0 ], out[ 1 ] );\n}\n\n\n// EXPORTS //\n\nexport default cdiv;\n"],"names":["internalCompreal","re1","im1","re2","im2","r","t","br","robustInternal","out","LARGE_THRESHOLD","FLOAT64_BIGGEST","SMALL_THRESHOLD","FLOAT64_SMALLEST","EPS","RECIP_EPS_SQR","cdiv","z1","z2","ab","cd","s","real","imag","max","abs","Complex128"],"mappings":";;ywBAwCA,SAASA,EAAkBC,EAAKC,EAAKC,EAAKC,EAAKC,EAAGC,GACjD,IAAIC,EACJ,OAAW,IAANF,GACKJ,EAAOG,GAAOF,EAAIC,IAAUG,EAG1B,KADZC,EAAKL,EAAMG,GAEDJ,EAAIK,EAASJ,EAAII,EAAKD,GAEvBJ,EAAIM,GAAOD,CACrB,CCPA,SAASE,EAAgBP,EAAKC,EAAKC,EAAKC,GACvC,IAAIK,EACAJ,EACAC,EAQJ,OAJAA,EAAI,GAAQH,EAAOC,GADnBC,EAAID,EAAMD,KADVM,EAAM,CAAE,EAAK,IAIR,GAAMT,EAAkBC,EAAKC,EAAKC,EAAKC,EAAKC,EAAGC,GACpDG,EAAK,GAAMT,EAAkBE,GAAMD,EAAKE,EAAKC,EAAKC,EAAGC,GAC9CG,CACR,CCpBA,IAAIC,EAAoC,GAAlBC,EAClBC,EAAkBC,GAAqB,EAAMC,GAC7CC,EAAgB,GAAQD,EAAMA,GAoClC,SAASE,EAAMC,EAAIC,GAClB,IAAIjB,EACAE,EACAD,EACAE,EACAK,EACAU,EACAC,EACAC,EAqCJ,OAnCApB,EAAMqB,EAAML,GACZd,EAAMmB,EAAMJ,GACZhB,EAAMqB,EAAMN,GACZb,EAAMmB,EAAML,GAEZC,EAAKK,EAAKC,EAAIxB,GAAMwB,EAAIvB,IACxBkB,EAAKI,EAAKC,EAAItB,GAAMsB,EAAIrB,IACxBiB,EAAI,EAECF,GAAMT,GACVT,GAAO,GACPC,GAAO,GACPmB,GAAK,GACMF,GAAMP,IACjBX,GAAOc,EACPb,GAAOa,EACPM,GAAKN,GAEDK,GAAMV,GACVP,GAAO,GACPC,GAAO,GACPiB,GAAK,IACMD,GAAMR,IACjBT,GAAOY,EACPX,GAAOW,EACPM,GAAKN,GAEDU,EAAKrB,IAASqB,EAAKtB,GACvBM,EAAMD,EAAgBP,EAAKC,EAAKC,EAAKC,IAErCK,EAAMD,EAAgBN,EAAKD,EAAKG,EAAKD,IAChC,KAAQ,EAEdM,EAAK,IAAOY,EACZZ,EAAK,IAAOY,EACL,IAAIK,EAAYjB,EAAK,GAAKA,EAAK,GACvC"}