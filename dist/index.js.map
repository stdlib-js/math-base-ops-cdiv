{
  "version": 3,
  "sources": ["../lib/internal_compreal.js", "../lib/robust_internal.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Computes the real part of the quotient.\n*\n* ## Notes\n*\n* -   See figure 10 of [Baudin (2012)][@baudin:2012].\n*\n* [@baudin:2012]: https://arxiv.org/abs/1210.4539\n*\n* @private\n* @param {number} re1 - real component\n* @param {number} im1 - imaginary component\n* @param {number} re2 - real component\n* @param {number} im2 - imaginary component\n* @param {number} r - partial result\n* @param {number} t - partial result\n* @returns {number} real part of the quotient\n*/\nfunction internalCompreal( re1, im1, re2, im2, r, t ) {\n\tvar br;\n\tif ( r === 0.0 ) {\n\t\treturn ( re1 + (im2 * (im1/re2)) ) * t;\n\t}\n\tbr = im1 * r;\n\tif ( br === 0.0 ) {\n\t\treturn ( re1*t ) + ( (im1*t) * r );\n\t}\n\treturn ( re1+br ) * t;\n}\n\n\n// EXPORTS //\n\nmodule.exports = internalCompreal;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar internalCompreal = require( './internal_compreal.js' );\n\n\n// MAIN //\n\n/**\n* Computes the complex division.\n*\n* ## Notes\n*\n* -   See figure 10 of [reference][@baudin:2012].\n*\n* [@baudin:2012]: https://arxiv.org/abs/1210.4539\n*\n* @private\n* @param {number} re1 - real component\n* @param {number} im1 - imaginary component\n* @param {number} re2 - real component\n* @param {number} im2 - imaginary component\n* @returns {Array<number>} result\n*/\nfunction robustInternal( re1, im1, re2, im2 ) {\n\tvar out;\n\tvar r;\n\tvar t;\n\n\tout = [ 0.0, 0.0 ];\n\tr = im2 / re2;\n\tt = 1.0 / ( re2 + (im2*r) );\n\n\tout[ 0 ] = internalCompreal( re1, im1, re2, im2, r, t );\n\tout[ 1 ] = internalCompreal( im1, -re1, re2, im2, r, t );\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = robustInternal;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar abs = require( '@stdlib/math-base-special-abs' );\nvar max = require( '@stdlib/math-base-special-max' );\nvar FLOAT64_BIGGEST = require( '@stdlib/constants-float64-max' );\nvar FLOAT64_SMALLEST = require( '@stdlib/constants-float64-smallest-normal' );\nvar EPS = require( '@stdlib/constants-float64-eps' );\nvar real = require( '@stdlib/complex-float64-real' );\nvar imag = require( '@stdlib/complex-float64-imag' );\nvar Complex128 = require( '@stdlib/complex-float64-ctor' );\nvar robustInternal = require( './robust_internal.js' );\n\n\n// VARIABLES //\n\nvar LARGE_THRESHOLD = FLOAT64_BIGGEST * 0.5;\nvar SMALL_THRESHOLD = FLOAT64_SMALLEST * ( 2.0 / EPS );\nvar RECIP_EPS_SQR = 2.0 / ( EPS * EPS );\n\n\n// MAIN //\n\n/**\n* Divides two double-precision complex floating-point numbers.\n*\n* ## References\n*\n* -   Baudin, Michael, and Robert L. Smith. 2012. \"A Robust Complex Division in Scilab.\" _arXiv_ abs/1210.4539 \\[cs.MS\\] (October): 1\u201325. <https://arxiv.org/abs/1210.4539>.\n*\n* @param {Complex128} z1 - complex number\n* @param {Complex128} z2 - complex number\n* @returns {Complex128} result\n*\n* @example\n* var Complex128 = require( '@stdlib/complex-float64-ctor' );\n* var real = require( '@stdlib/complex-float64-real' );\n* var imag = require( '@stdlib/complex-float64-imag' );\n*\n* var z1 = new Complex128( -13.0, -1.0 );\n* // returns <Complex128>\n*\n* var z2 = new Complex128( -2.0, 1.0 );\n* // returns <Complex128>\n*\n* var out = cdiv( z1, z2 );\n* // returns <Complex128>\n*\n* var re = real( out );\n* // returns 5.0\n*\n* var im = imag( out );\n* // returns 3.0\n*/\nfunction cdiv( z1, z2 ) {\n\tvar re1;\n\tvar re2;\n\tvar im1;\n\tvar im2;\n\tvar out;\n\tvar ab;\n\tvar cd;\n\tvar s;\n\n\tre1 = real( z1 );\n\tre2 = real( z2 );\n\tim1 = imag( z1 );\n\tim2 = imag( z2 );\n\n\tab = max( abs(re1), abs(im1) );\n\tcd = max( abs(re2), abs(im2) );\n\ts = 1.0;\n\n\tif ( ab >= LARGE_THRESHOLD ) {\n\t\tre1 *= 0.5;\n\t\tim1 *= 0.5;\n\t\ts *= 2.0;\n\t} else if ( ab <= SMALL_THRESHOLD ) {\n\t\tre1 *= RECIP_EPS_SQR;\n\t\tim1 *= RECIP_EPS_SQR;\n\t\ts /= RECIP_EPS_SQR;\n\t}\n\tif ( cd >= LARGE_THRESHOLD ) {\n\t\tre2 *= 0.5;\n\t\tim2 *= 0.5;\n\t\ts *= 0.5;\n\t} else if ( cd <= SMALL_THRESHOLD ) {\n\t\tre2 *= RECIP_EPS_SQR;\n\t\tim2 *= RECIP_EPS_SQR;\n\t\ts *= RECIP_EPS_SQR;\n\t}\n\tif ( abs( im2 ) <= abs( re2 ) ) {\n\t\tout = robustInternal( re1, im1, re2, im2 );\n\t} else {\n\t\tout = robustInternal( im1, re1, im2, re2 );\n\t\tout[ 1 ] *= -1.0;\n\t}\n\tout[ 0 ] *= s;\n\tout[ 1 ] *= s;\n\treturn new Complex128( out[ 0 ], out[ 1 ] );\n}\n\n\n// EXPORTS //\n\nmodule.exports = cdiv;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Divide two double-precision complex floating-point numbers.\n*\n* @module @stdlib/math-base-ops-cdiv\n*\n* @example\n* var Complex128 = require( '@stdlib/complex-float64-ctor' );\n* var real = require( '@stdlib/complex-float64-real' );\n* var imag = require( '@stdlib/complex-float64-imag' );\n* var cdiv = require( '@stdlib/math-base-ops-cdiv' );\n*\n* var z1 = new Complex128( -13.0, -1.0 );\n* // returns <Complex128>\n*\n* var z2 = new Complex128( -2.0, 1.0 );\n* // returns <Complex128>\n*\n* var out = cdiv( z1, z2 );\n* // returns <Complex128>\n*\n* var re = real( out );\n* // returns 5.0\n*\n* var im = imag( out );\n* // returns 3.0\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAwCA,SAASC,EAAkBC,EAAKC,EAAKC,EAAKC,EAAKC,EAAGC,EAAI,CACrD,IAAIC,EACJ,OAAKF,IAAM,GACDJ,EAAOG,GAAOF,EAAIC,IAAUG,GAEtCC,EAAKL,EAAMG,EACNE,IAAO,EACFN,EAAIK,EAASJ,EAAII,EAAKD,GAEvBJ,EAAIM,GAAOD,EACrB,CAKAP,EAAO,QAAUC,ICvDjB,IAAAQ,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAmB,IAqBvB,SAASC,EAAgBC,EAAKC,EAAKC,EAAKC,EAAM,CAC7C,IAAIC,EACA,EACAC,EAEJ,OAAAD,EAAM,CAAE,EAAK,CAAI,EACjB,EAAID,EAAMD,EACVG,EAAI,GAAQH,EAAOC,EAAI,GAEvBC,EAAK,CAAE,EAAIN,EAAkBE,EAAKC,EAAKC,EAAKC,EAAK,EAAGE,CAAE,EACtDD,EAAK,CAAE,EAAIN,EAAkBG,EAAK,CAACD,EAAKE,EAAKC,EAAK,EAAGE,CAAE,EAChDD,CACR,CAKAP,EAAO,QAAUE,IC5DjB,IAAAO,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAsBA,IAAIC,EAAM,QAAS,+BAAgC,EAC/CC,EAAM,QAAS,+BAAgC,EAC/CC,EAAkB,QAAS,+BAAgC,EAC3DC,EAAmB,QAAS,2CAA4C,EACxEC,EAAM,QAAS,+BAAgC,EAC/CC,EAAO,QAAS,8BAA+B,EAC/CC,EAAO,QAAS,8BAA+B,EAC/CC,EAAa,QAAS,8BAA+B,EACrDC,EAAiB,IAKjBC,EAAkBP,EAAkB,GACpCQ,EAAkBP,GAAqB,EAAMC,GAC7CO,EAAgB,GAAQP,EAAMA,GAoClC,SAASQ,EAAMC,EAAIC,EAAK,CACvB,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEJ,OAAAP,EAAMV,EAAMQ,CAAG,EACfG,EAAMX,EAAMS,CAAG,EACfG,EAAMX,EAAMO,CAAG,EACfK,EAAMZ,EAAMQ,CAAG,EAEfM,EAAKnB,EAAKD,EAAIe,CAAG,EAAGf,EAAIiB,CAAG,CAAE,EAC7BI,EAAKpB,EAAKD,EAAIgB,CAAG,EAAGhB,EAAIkB,CAAG,CAAE,EAC7BI,EAAI,EAECF,GAAMX,GACVM,GAAO,GACPE,GAAO,GACPK,GAAK,GACMF,GAAMV,IACjBK,GAAOJ,EACPM,GAAON,EACPW,GAAKX,GAEDU,GAAMZ,GACVO,GAAO,GACPE,GAAO,GACPI,GAAK,IACMD,GAAMX,IACjBM,GAAOL,EACPO,GAAOP,EACPW,GAAKX,GAEDX,EAAKkB,CAAI,GAAKlB,EAAKgB,CAAI,EAC3BG,EAAMX,EAAgBO,EAAKE,EAAKD,EAAKE,CAAI,GAEzCC,EAAMX,EAAgBS,EAAKF,EAAKG,EAAKF,CAAI,EACzCG,EAAK,CAAE,GAAK,IAEbA,EAAK,CAAE,GAAKG,EACZH,EAAK,CAAE,GAAKG,EACL,IAAIf,EAAYY,EAAK,CAAE,EAAGA,EAAK,CAAE,CAAE,CAC3C,CAKApB,EAAO,QAAUa,IC3EjB,IAAIW,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_internal_compreal", "__commonJSMin", "exports", "module", "internalCompreal", "re1", "im1", "re2", "im2", "r", "t", "br", "require_robust_internal", "__commonJSMin", "exports", "module", "internalCompreal", "robustInternal", "re1", "im1", "re2", "im2", "out", "t", "require_main", "__commonJSMin", "exports", "module", "abs", "max", "FLOAT64_BIGGEST", "FLOAT64_SMALLEST", "EPS", "real", "imag", "Complex128", "robustInternal", "LARGE_THRESHOLD", "SMALL_THRESHOLD", "RECIP_EPS_SQR", "cdiv", "z1", "z2", "re1", "re2", "im1", "im2", "out", "ab", "cd", "s", "main"]
}
